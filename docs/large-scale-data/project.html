<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-57255bc51a02dad1602480f616b5f366.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="sec-lsd-project" class="level1">
<h1>Project: Distributed Data Analysis</h1>
<p>In this project, you will learn to use Spark to clean a large dataset, do feature engineering, do analytics reporting, and fit machine learning models.</p>
<p>We will work with a large dataset of US airline flights. You may have used a subset of this data in a course before, but here we’ll use the full data for ten years. We’ll begin by using Spark to aggregate and summarize the data, before moving on to feature engineering and building models to predict on-time performance.</p>
<section id="logistics" class="level2">
<h2 class="anchored" data-anchor-id="logistics">Logistics</h2>
<p>This project will be completed in assigned groups of 2 or 3 students. Group assignments will be posted on Canvas. There will be several milestones throughout the semester when you will turn in parts of the work; at the end of the mini, you will turn in the completed project.</p>
</section>
<section id="data-description" class="level2">
<h2 class="anchored" data-anchor-id="data-description">Data description</h2>
<p>The dataset is loaded in Parquet files on our Spark cluster. They live in the <code>sampledata</code> container of the <code>madsdatastore</code> storage account in Azure Data Lake Storage. There is one CSV file per year, but fortunately Spark can read them all at once:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>delays <span class="op">=</span> spark.read.csv(<span class="st">"abfss://sampledata@lsd2025storage.dfs.core.windows.net/delays"</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                        header<span class="op">=</span><span class="va">True</span>, nullValue<span class="op">=</span><span class="st">"NULL"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This will only work in the Class Shared Cluster, since it is configured with the necessary keys to have access to the data.</p>
<p>The data includes the following columns:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Variable</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FL_DATE</td>
<td>Date of flight (YYYY-mm-dd)</td>
</tr>
<tr class="even">
<td>OP_CARRIER</td>
<td>Code assigned by International Air Transport Association to identify each airline; Wikipedia has a <a href="https://en.wikipedia.org/wiki/List_of_airline_codes">full table of them</a>.</td>
</tr>
<tr class="odd">
<td>OP_CARRIER_FL_NUM</td>
<td>Flight number assigned by this carrier for the flight.</td>
</tr>
<tr class="even">
<td>ORIGIN</td>
<td>IATA code for the airport the flight left from. Wikipedia has a <a href="https://en.wikipedia.org/wiki/Lists_of_airports_by_IATA_and_ICAO_code">list of airports by IATA code</a>.</td>
</tr>
<tr class="odd">
<td>DEST</td>
<td>IATA code for the destination airport.</td>
</tr>
<tr class="even">
<td>CRS_DEP_TIME</td>
<td>Scheduled departure time (local time, hhmm).</td>
</tr>
<tr class="odd">
<td>DEP_TIME</td>
<td>Actual departure time (local time, hhmm).</td>
</tr>
<tr class="even">
<td>DEP_DELAY</td>
<td>Difference in minutes between scheduled and actual departure time. Early departures show negative numbers.</td>
</tr>
<tr class="odd">
<td>TAXI_OUT</td>
<td>Time taken to taxi out to the runway, in minutes.</td>
</tr>
<tr class="even">
<td>WHEELS_OFF</td>
<td>Time the flight took off (local time, hhmm).</td>
</tr>
<tr class="odd">
<td>WHEELS_ON</td>
<td>Time the flight landed (local time, hhmm).</td>
</tr>
<tr class="even">
<td>TAXI_IN</td>
<td>Time taken to taxi in to the gate, in minutes.</td>
</tr>
<tr class="odd">
<td>CRS_ARR_TIME</td>
<td>Scheduled arrival time (local time, hhmm).</td>
</tr>
<tr class="even">
<td>ARR_TIME</td>
<td>Actual arrival time (local time, hhmm).</td>
</tr>
<tr class="odd">
<td>ARR_DELAY</td>
<td>Difference in minutes between scheduled and actual arrival time. Early arrivals show negative numbers.</td>
</tr>
<tr class="even">
<td>CANCELLED</td>
<td>1 if the flight was cancelled.</td>
</tr>
<tr class="odd">
<td>DIVERTED</td>
<td>1 if the flight was diverted.</td>
</tr>
<tr class="even">
<td>CRS_ELAPSED_TIME</td>
<td>Scheduled duration of the flight, in minutes.</td>
</tr>
<tr class="odd">
<td>ACTUAL_ELAPSED_TIME</td>
<td>Elapsed time of flight, in minutes.</td>
</tr>
<tr class="even">
<td>AIR_TIME</td>
<td>Time the flight was in the air, in minutes.</td>
</tr>
<tr class="odd">
<td>DISTANCE</td>
<td>Distance between origin and destination airports, in miles.</td>
</tr>
<tr class="even">
<td>CARRIER_DELAY</td>
<td>Length of delay caused by the airline (e.g.&nbsp;maintenance, waiting for crew, cleaning the plane), in minutes. Note that if the flight was not delayed, these fields will be blank.</td>
</tr>
<tr class="odd">
<td>WEATHER_DELAY</td>
<td>Length of delay caused by weather, in minutes.</td>
</tr>
<tr class="even">
<td>NAS_DELAY</td>
<td>Length of delay caused by the National Airspace System, including air traffic control, in minutes.</td>
</tr>
<tr class="odd">
<td>SECURITY_DELAY</td>
<td>Length of delay caused by a security problem, such as evacuation of a terminal or excessive security lines, in minutes.</td>
</tr>
<tr class="even">
<td>LATE_AIRCRAFT_DELAY</td>
<td>Length of delay caused because the aircraft arrived late from its previous airport, in minutes.</td>
</tr>
</tbody>
</table>
</section>
<section id="part-1-basic-data-exploration" class="level2">
<h2 class="anchored" data-anchor-id="part-1-basic-data-exploration">Part 1: Basic data exploration</h2>
<p>This part is due Friday, February 7 at 5pm.</p>
<p>First, create a notebook in the Databricks workspace for cleaning and formatting the data. Ensure you can load the data and consolidate it into one Spark DataFrame. Examine the columns and their types. Do any columns need to be converted to specific types? Review the <a href="https://spark.apache.org/docs/latest/sql-ref-datatypes.html">Spark data types reference</a>; the <a href="https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql/functions.html">PySpark functions reference</a> lists functions that can do conversion and manipulation.</p>
<p>Have your notebook do all the necessary manipulation. At the end of the notebook, write your new data frame into the metastore. Choose a table name that is unique to your group, and write it with:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>your_data_frame.write.saveAsTable(<span class="st">"hive_metastore.default.your_group_table_name"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next, create a new notebook in the Databricks workspace. In the notebook, calculate (using Spark) and present the following aggregates:</p>
<ul>
<li>A summary table or graph showing the number of flights per month across the history of the data, so you know you’ve loaded everything</li>
<li>The percentage of flights delayed per week, plotted over the entire length of the data</li>
<li>The number of delayed flights per week, by type of delay, plotted over time</li>
<li>A table of air carriers, showing the number of flights scheduled, the number canceled, the percentage delayed, and the average delay among those delayed. Sort by total number of flights, so the biggest air carriers come first.</li>
<li>A table of the top 50 airports by percentage of flights delayed, showing the airport code, percentage of flights delayed, and average number of flights per day</li>
</ul>
</section>
<section id="part-2-feature-engineering" class="level2">
<h2 class="anchored" data-anchor-id="part-2-feature-engineering">Part 2: Feature engineering</h2>
<p>This part is due Friday, February 14 at 5pm.</p>
<p>Our ultimate goal is to build a predictive model for flight delays. Given a flight and various features, your model should predict whether the flight is delayed for any reason. (We’ll count cancellation as a type of delay.)</p>
<p>You could use only the variables present in the data, but it is likely that you can derive new features that would be more useful.</p>
<p>Create a notebook that generates the following additional features for each observation:</p>
<ul>
<li>The day of week (Monday-Sunday)</li>
<li>Rate of weather delays at the departure airport in the previous hour (the fraction of flights in the previous hour that were delayed due to weather)</li>
<li>Rate of weather delays from the arrival airport in the previous hour</li>
<li>Number of flights departing from the departure airport in the previous hour, compared the average number during this hour on the same day of the week, as a <em>z</em> score</li>
<li>At least two more features, calculated from the available data, that you think could be useful for your model</li>
</ul>
</section>
<section id="part-3-delay-prediction" class="level2">
<h2 class="anchored" data-anchor-id="part-3-delay-prediction">Part 3: Delay prediction</h2>
<p>This part is due Friday, February 28 at 5pm.</p>
<p>Now we aim to use Spark ML and the features you created in Part 2 to predict departure delays. Create a notebook and use your feature engineering code to augment the entire dataset with features.</p>
<p>Next, split the data into training, test, and validation sets. Based on how you did the feature engineering, should your split be fully random, or do you need to do another approach? In any case, reserve at least 20% of the data for final validation, and do not use it when building and testing your models.</p>
<p>Now apply Spark ML to predict departure delays. Using your training and test sets, choose the right classifier, tune its parameters, and calculate its performance.</p>
<p>Once you are done, evaluate your model’s performance on the held-out validation set. Report the accuracy, but break it down as well: produce the full confusion matrix, the true positive and false positive rates, and the sensitivity and specificity. Compare it to a baseline model that always predicts “no delay”. How much better is your model?</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>